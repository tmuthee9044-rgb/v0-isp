import { exec } from "node:child_process"
import { promisify } from "node:util"
import { writeFile, readFile } from "node:fs/promises"
import { getSql } from "./db"

const execAsync = promisify(exec)

interface RouterConfig {
  id: number
  name: string
  ip_address: string
  vendor?: string
  radius_secret?: string
  status: string
}

/**
 * Generate FreeRADIUS client configuration for all active routers
 * Supports multiple vendors: MikroTik, Cisco, Ubiquiti, etc.
 */
export async function generateFreeRADIUSClientsConfig(): Promise<string> {
  try {
    const sql = await getSql()
    
    // Fetch all active routers with RADIUS configuration
    const routers = await sql<RouterConfig[]>`
      SELECT 
        nr.id,
        nr.name,
        nr.ip_address,
        nr.vendor,
        nr.radius_secret,
        nr.status
      FROM network_devices nr
      WHERE nr.status = 'active'
      AND nr.ip_address IS NOT NULL
      ORDER BY nr.id ASC
    `

    console.log(`[v0] Generating FreeRADIUS config for ${routers.length} active routers`)

    // Get default RADIUS secret from system config if not set per-router
    const systemConfig = await sql`
      SELECT value FROM system_config WHERE key = 'radius_server_secret' LIMIT 1
    `
    const defaultSecret = systemConfig[0]?.value || "testing123"

    // Generate client configuration
    let config = `# FreeRADIUS Clients Configuration
# Auto-generated by ISP Management System
# DO NOT EDIT MANUALLY - Changes will be overwritten
# Last updated: ${new Date().toISOString()}

`

    for (const router of routers) {
      const secret = router.radius_secret || defaultSecret
      const vendor = router.vendor?.toLowerCase() || "other"
      const nasType = getNASType(vendor)

      config += `# Router: ${router.name} (ID: ${router.id})
client ${sanitizeName(router.name)}_${router.id} {
    ipaddr = ${router.ip_address}
    secret = ${secret}
    shortname = ${sanitizeName(router.name)}
    nastype = ${nasType}
    require_message_authenticator = no
    limit {
        max_connections = 16
        lifetime = 0
        idle_timeout = 30
    }
}

`
    }

    // Add localhost for testing
    config += `# Localhost client for testing
client localhost {
    ipaddr = 127.0.0.1
    secret = testing123
    shortname = localhost
    nastype = other
}

`

    return config
  } catch (error) {
    console.error("[v0] Error generating FreeRADIUS config:", error)
    throw error
  }
}

/**
 * Map vendor name to FreeRADIUS NAS type
 */
function getNASType(vendor: string): string {
  const vendorMap: Record<string, string> = {
    mikrotik: "mikrotik",
    cisco: "cisco",
    ubiquiti: "other",
    unifi: "other",
    huawei: "other",
    juniper: "other",
    aruba: "other",
    hp: "other",
    dell: "other",
  }

  return vendorMap[vendor] || "other"
}

/**
 * Sanitize router name for use in client configuration
 */
function sanitizeName(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9_-]/g, "_")
    .replace(/_{2,}/g, "_")
    .substring(0, 50)
}

/**
 * Write FreeRADIUS clients configuration to file and reload service
 */
export async function updateFreeRADIUSConfig(): Promise<{
  success: boolean
  message: string
  configPath?: string
}> {
  try {
    console.log("[v0] Updating FreeRADIUS clients configuration...")

    // Generate new configuration
    const config = await generateFreeRADIUSClientsConfig()

    // Determine FreeRADIUS config path (try common locations)
    const possiblePaths = [
      "/etc/freeradius/3.0/clients.conf",
      "/etc/raddb/clients.conf",
      "/etc/freeradius/clients.conf",
      "/usr/local/etc/raddb/clients.conf",
    ]

    let configPath: string | null = null
    for (const path of possiblePaths) {
      try {
        await readFile(path)
        configPath = path
        console.log(`[v0] Found FreeRADIUS config at: ${path}`)
        break
      } catch {
        continue
      }
    }

    if (!configPath) {
      console.warn("[v0] FreeRADIUS config file not found, using default path")
      configPath = possiblePaths[0]
    }

    // Backup existing config
    try {
      const existingConfig = await readFile(configPath, "utf-8")
      const backupPath = `${configPath}.backup.${Date.now()}`
      await writeFile(backupPath, existingConfig)
      console.log(`[v0] Backed up existing config to: ${backupPath}`)
    } catch (error) {
      console.log("[v0] No existing config to backup or backup failed")
    }

    // Write new configuration
    await writeFile(configPath, config, { mode: 0o644 })
    console.log(`[v0] Wrote FreeRADIUS config to: ${configPath}`)

    // Test configuration validity (non-blocking - FreeRADIUS may not be installed on dev systems)
    try {
      const { stdout, stderr } = await execAsync("radiusd -XC 2>&1", { timeout: 5000 })
      console.log("[v0] FreeRADIUS config test passed:", stdout.substring(0, 200))
      if (stderr) {
        console.warn("[v0] FreeRADIUS config test warnings:", stderr.substring(0, 200))
      }
    } catch (error: any) {
      console.error("[v0] FreeRADIUS config test failed:", error.stderr || error.message)
      
      // Check if it's just because radiusd is not installed (dev environment)
      if (error.message?.includes("command not found") || error.message?.includes("ENOENT")) {
        console.warn("[v0] radiusd command not found - skipping validation (dev environment)")
      } else {
        // Real config error - restore backup
        try {
          const backupFiles = await execAsync(`ls -t ${configPath}.backup.* 2>/dev/null | head -1`)
          const latestBackup = backupFiles.stdout.trim()
          if (latestBackup) {
            const backupContent = await readFile(latestBackup, "utf-8")
            await writeFile(configPath, backupContent)
            console.log("[v0] Restored backup config due to test failure")
            return {
              success: false,
              message: `Invalid FreeRADIUS configuration - restored backup. Error: ${error.stderr || error.message}`,
            }
          }
        } catch {
          console.error("[v0] Failed to restore backup")
        }
        console.warn("[v0] Config may be invalid but proceeding anyway")
      }
    }

    // Reload FreeRADIUS service (try multiple methods)
    try {
      // Try systemctl first
      await execAsync("systemctl reload freeradius 2>&1", { timeout: 10000 })
      console.log("[v0] FreeRADIUS service reloaded via systemctl")
    } catch (error: any) {
      console.log("[v0] systemctl reload failed, trying service command...")
      try {
        await execAsync("service freeradius reload 2>&1", { timeout: 10000 })
        console.log("[v0] FreeRADIUS service reloaded via service command")
      } catch (error2: any) {
        console.warn("[v0] Failed to reload FreeRADIUS automatically:", error2.message)
        console.warn("[v0] Please restart FreeRADIUS manually with: systemctl restart freeradius")
        // Non-fatal - config is still written and valid
      }
    }

    return {
      success: true,
      message: "FreeRADIUS configuration updated successfully",
      configPath,
    }
  } catch (error: any) {
    console.error("[v0] Error updating FreeRADIUS config:", error)
    return {
      success: false,
      message: error.message || "Failed to update FreeRADIUS configuration",
    }
  }
}
